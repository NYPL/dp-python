<h2 id="goals">Goals</h2>

<ul>
  <li>Understanding shell, terminal, and path</li>
  <li>Customizing the shell environment</li>
  <li>Customizing a prompt</li>
</ul>

<h2 id="terminal-shell-and-session">Terminal, Shell, and Session</h2>

<p>The terminal/shell/bash/etc can be mysterious.
Everyone calls it something different.
The default interface gives you nothing, just a blinking cursor.</p>

<p>First off, terminology.</p>

<ul>
  <li>shell - An interface by which to launch other programs. Typically refers to a command-line interface.</li>
  <li><code class="language-plaintext highlighter-rouge">bash</code>/<code class="language-plaintext highlighter-rouge">zsh</code>/<code class="language-plaintext highlighter-rouge">fish</code>/<code class="language-plaintext highlighter-rouge">sh</code> - Different shells, each with different features. <code class="language-plaintext highlighter-rouge">sh</code> is one of the earliest shells. <code class="language-plaintext highlighter-rouge">bash</code> is the default Linux and pre-MacOS 10.11 shell. <code class="language-plaintext highlighter-rouge">zsh</code> is the current MacOs shell.</li>
  <li>terminal/console - The program/device that runs a shell. One terminal can run multiple shells.</li>
  <li>session - a single running instance of a shell.</li>
</ul>

<p>As an example, when you open Terminal on macOS, it automatically starts a session of <code class="language-plaintext highlighter-rouge">zsh</code>.
If you don’t like <code class="language-plaintext highlighter-rouge">zsh</code>, you can run a different shell, if it’s installed.
Running the command <code class="language-plaintext highlighter-rouge">bash</code> starts a session of that shell, within the already running <code class="language-plaintext highlighter-rouge">zsh</code> session.
If you want to leave the <code class="language-plaintext highlighter-rouge">bash</code> session, run <code class="language-plaintext highlighter-rouge">exit</code> and you’ll return to the original <code class="language-plaintext highlighter-rouge">zsh</code> session.
If you open a new tab in Terminal, it will start another <code class="language-plaintext highlighter-rouge">zsh</code> session.</p>

<p>The important thing about sessions is that programs depend on the session they were started in.
From the previous example, if you start transcoding a video file in the second tab and then close the first tab, it does not affect the transcode.
If you close the tab where the transcode is running or the terminal window that holds the tab, the transcode will stop.</p>

<p>It’s useful to build an understanding of how these concepts relate as you use command line more often.
For example, using <code class="language-plaintext highlighter-rouge">ssh</code> to connect to a virtual machine starts a shell session on that virtual machine.
Closing the <code class="language-plaintext highlighter-rouge">ssh</code> session, the shell session you ran <code class="language-plaintext highlighter-rouge">ssh</code> in, or the terminal for that shell session, will stop whatever process you started on the VM, unless you take specific actions to avoid it.</p>

<p>It’s also useful to know and use the more correct terminology.
Since macOS now uses <code class="language-plaintext highlighter-rouge">zsh</code> by default, it feels strange to advise someone to “learn <code class="language-plaintext highlighter-rouge">bash</code>”.
Better advise would be to learn command-line interfaces, using terminals, programming in a shell, or other more general statements.
Of course, we’re not going to fix the general confusion over terminology here, and these lessons likely still make plenty of mistakes.
As will all things technology, <a href="https://en.wikipedia.org/wiki/Robustness_principle">“Be liberal in what you accept, and conservative in what you send.”</a></p>

<h2 id="path">PATH</h2>

<p>How does a shell take input like <code class="language-plaintext highlighter-rouge">ls</code> and understand to run a program called program that returns a directory listing?
In brief, the shell is configured to look in a few locations for a program called <code class="language-plaintext highlighter-rouge">ls</code>.
Those locations are defined in a variable called <code class="language-plaintext highlighter-rouge">PATH</code> in most shells.
To see your <code class="language-plaintext highlighter-rouge">PATH</code>, print it in a shell session.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="nv">$PATH</span>
</code></pre></div></div>

<p>(The <code class="language-plaintext highlighter-rouge">$</code> in the command is required for the shell to understand to look for a variable.
Otherwise, <code class="language-plaintext highlighter-rouge">echo</code>  will try to open a file in the current working directory called <code class="language-plaintext highlighter-rouge">PATH</code>, which probably doesn’t exist.)</p>

<p>A default <code class="language-plaintext highlighter-rouge">PATH</code> might look like this.
<code class="language-plaintext highlighter-rouge">/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</code>
The shell interprets this as four locations: <code class="language-plaintext highlighter-rouge">/usr/local/bin</code>, <code class="language-plaintext highlighter-rouge">/usr/bin</code>, <code class="language-plaintext highlighter-rouge">/bin</code>, <code class="language-plaintext highlighter-rouge">/usr/sbin</code>, and <code class="language-plaintext highlighter-rouge">/sbin</code>.
It will looks for a file called <code class="language-plaintext highlighter-rouge">ls</code> in each location starting from <code class="language-plaintext highlighter-rouge">/usr/local/bin</code> until it finds a file, and then run that file.</p>

<p>We can mimic this behavior by listing the contents of each folder, and searching for a file called <code class="language-plaintext highlighter-rouge">ls</code></p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> /usr/local/bin | <span class="nb">grep</span> ^ls<span class="err">$</span>
<span class="nb">ls</span> /usr/bin | <span class="nb">grep</span> ^ls<span class="err">$</span>
<span class="nb">ls</span> /bin | <span class="nb">grep</span> ^ls<span class="err">$</span>
<span class="o">&gt;</span> <span class="nb">ls</span>
</code></pre></div></div>

<p>It doesn’t matter if there is an <code class="language-plaintext highlighter-rouge">ls</code> in <code class="language-plaintext highlighter-rouge">/usr/sbin</code> or <code class="language-plaintext highlighter-rouge">/sbin</code>.
The shell stops searching as soon as it finds the copy in <code class="language-plaintext highlighter-rouge">/bin</code>.</p>

<p>If we wanted to use a different version of <code class="language-plaintext highlighter-rouge">ls</code> without overwriting the default version, we could install a file to <code class="language-plaintext highlighter-rouge">/usr/local/bin</code> or <code class="language-plaintext highlighter-rouge">/usr/bin</code>.
We could also install it to a different folder, and add that folder to the <code class="language-plaintext highlighter-rouge">PATH</code>.</p>

<p>A more complex <code class="language-plaintext highlighter-rouge">PATH</code> might look like this.</p>

<p><code class="language-plaintext highlighter-rouge">/Users/Alice/.pyenv/shims:/Users/Alice/.pyenv/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</code></p>

<p>The user named Alice has configured their shell with two additional programs, <code class="language-plaintext highlighter-rouge">pyenv</code> and <code class="language-plaintext highlighter-rouge">homebrew</code>.
Programs installed via <code class="language-plaintext highlighter-rouge">pyenv</code> and <code class="language-plaintext highlighter-rouge">homebrew</code> are found in <code class="language-plaintext highlighter-rouge">~/.pyenv/shims</code>, <code class="language-plaintext highlighter-rouge">~/.pyenv/bin</code>, <code class="language-plaintext highlighter-rouge">/opt/homebrew/bin</code>, and <code class="language-plaintext highlighter-rouge">/opt/homebrew/sbin</code>.
If Alice wants the updated version of <code class="language-plaintext highlighter-rouge">ls</code> available on homebrew, it is installed to <code class="language-plaintext highlighter-rouge">/opt/homebrew/bin</code>, leaving the original alone.</p>

<p>Adding instead of overwriting is a good technology practice.
What if the most recent version of <code class="language-plaintext highlighter-rouge">ls</code> is utterly broken with some bug?
We can use <code class="language-plaintext highlighter-rouge">homebrew uninstall ls</code>.
But, how do we go back to the working version that we and system process rely on?
Backups?
Finding the original from some online repository?
The most reliable solution is to not disturb the original program.</p>

<p>How do we update <code class="language-plaintext highlighter-rouge">PATH</code>?
You might have seen instructions like this during an installation.
(Do not run this example.)</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span>/some/path/to/dir/:<span class="nv">$PATH</span>
</code></pre></div></div>

<p>Reading this from right to left:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$PATH</code> returns the current <code class="language-plaintext highlighter-rouge">PATH</code></li>
  <li><code class="language-plaintext highlighter-rouge">/some/path/to/dir:</code> is a string that should be printed in front of <code class="language-plaintext highlighter-rouge">PATH</code>, the colon is the required separator for <code class="language-plaintext highlighter-rouge">PATH</code></li>
  <li><code class="language-plaintext highlighter-rouge">PATH=</code> assigns the total string constructed to the right to <code class="language-plaintext highlighter-rouge">PATH</code>, overwriting whatever <code class="language-plaintext highlighter-rouge">PATH</code> was before</li>
  <li><code class="language-plaintext highlighter-rouge">export</code> updates the environment of the current shell session so that all process that use <code class="language-plaintext highlighter-rouge">PATH</code> retrieve the new value</li>
</ul>

<p>It’s important that <code class="language-plaintext highlighter-rouge">export</code> only updates <code class="language-plaintext highlighter-rouge">PATH</code> for the current session.
If you start a new session, <code class="language-plaintext highlighter-rouge">PATH</code> will not include the new value.
For that reason, you might see this command in installation instructions.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"export PATH=/some/path/to/dir/:</span><span class="nv">$PATH</span><span class="s2">"</span> <span class="o">&gt;&gt;</span> ~/.profile
</code></pre></div></div>

<p>Why the echo?
Why the <code class="language-plaintext highlighter-rouge">&gt;&gt;</code>?
What is <code class="language-plaintext highlighter-rouge">~/.profile</code>?</p>

<h2 id="customizing-your-shell-environment-with-a-profile">Customizing your shell environment with a profile</h2>

<p>Every time you load a shell session, it has a number of settings already configured.
These settings can be used by the programs you run during the session.
For example, <code class="language-plaintext highlighter-rouge">PATH</code> stores where programs should be searched for.
<code class="language-plaintext highlighter-rouge">HOME</code> stores the path of the directory that can be referenced as <code class="language-plaintext highlighter-rouge">~</code>.
These settings are the environment of the session.</p>

<p>Over time, you may wish to customize the default environment.
A common example is modifying <code class="language-plaintext highlighter-rouge">PATH</code> to access additional programs.
Part of the environment is a series of files where the settings are defined.
When the shell session starts, these files are loaded and executed in a specific order.
The first of these are system files that you generally shouldn’t edit.
The last of these files are in your home folder, and are where you can customize the shell environment, even overriding settings from the earlier files.
These user-defined files are often referred to as your profile.</p>

<p>The name of the profile file depends on the shell.
For <code class="language-plaintext highlighter-rouge">bash</code>, the recommended profile is <code class="language-plaintext highlighter-rouge">~/.bash_profile</code>.
For <code class="language-plaintext highlighter-rouge">zsh</code>, the recommended profile is <code class="language-plaintext highlighter-rouge">~/.zshrc</code>.
There are additional potential locations that are beyond my ability to discuss but can be researched on your own.
In this lesson, <code class="language-plaintext highlighter-rouge">~/.profile</code> is used to generically refer to the profile that is most appropriate for you.</p>

<p>Then what does the <code class="language-plaintext highlighter-rouge">echo "export PATH..." &gt;&gt; ~/.profile</code>?</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">echo</code> returns the <code class="language-plaintext highlighter-rouge">"export ..."</code> as a string instead of running it</li>
  <li><code class="language-plaintext highlighter-rouge">&gt;&gt; ~/.profile</code> appends that to the end of the profile file</li>
</ul>

<p>The command only appends the command to the profile.
Future shell sessions will run the code, but the current session is still running on the old profile.
To update the session with the new profile session, run <code class="language-plaintext highlighter-rouge">source ~/.profile</code></p>

<p>The problem with <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> appending to your profile is that the profile becomes a long list of contextless commands.
Since you are configuring your environment, you probably want to organize and annotate these lines.
As the <code class="language-plaintext highlighter-rouge">echo ... &gt;&gt;</code> indicates, the profile is a text file.
So let’s use a text editor instead.</p>

<p>There are shell-based text editors like <code class="language-plaintext highlighter-rouge">nano</code> (easier-to-use) and <code class="language-plaintext highlighter-rouge">vi</code> (more complicated).
These lesson use Visual Studio Code, so we’ll use that.
Adapt the following command with the path to your profile.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code"</span> ~/.profile
</code></pre></div></div>

<p>This should open the profile in a VS Code window.
Depending on how you’ve used your computer, this file might be empty or full.
If it is full, take some time to read through the various lines.
If there’s anything you don’t understand, you should probably add comments on the lines above.
If there’s anything that looks like a duplicate or conflict, think about cleaning it up.
Keep in mind that the profile is read and executed from top to bottom.</p>

<h3 id="adding-to-the-profile">Adding to the profile</h3>

<p>It is convenient to launch VS Code from the terminal, but cumbersome to use that path.
Let’s update the profile by adding the path to <code class="language-plaintext highlighter-rouge">code</code> to <code class="language-plaintext highlighter-rouge">PATH</code>.
In future shell sessions, we can open any file or directory in VS Code with the command <code class="language-plaintext highlighter-rouge">code path/to/dir/or/file</code></p>

<p>If the <code class="language-plaintext highlighter-rouge">PATH</code> has already been updated with the VS Code path, consider updating it with some of the advice below.</p>

<ol>
  <li>Go to the end of the file and add a couple new lines</li>
  <li>Add a comment about you addition, like “Launch VS Code from shell”</li>
  <li>Add a line to update the <code class="language-plaintext highlighter-rouge">PATH</code>. In this case, add the directory that contains <code class="language-plaintext highlighter-rouge">code</code> to the end of <code class="language-plaintext highlighter-rouge">PATH</code> since only one program will be found there. <code class="language-plaintext highlighter-rouge">export PATH="$PATH:/Applications/Visual Studio Code.app/Contents/Resources/app/bin"</code></li>
  <li>Add one more new line to the file to make it easier for future editors (yourself).</li>
  <li>Save the file.</li>
  <li>In your original shell session, run <code class="language-plaintext highlighter-rouge">source ~/.profile</code> and then <code class="language-plaintext highlighter-rouge">code</code> to test the change.</li>
</ol>

<pre><code class="language-txt">
# Launch VS Code from shell
export PATH="$PATH:/Applications/Visual Studio Code.app/Contents/Resources/app/bin"

</code></pre>

<p>Keep this loop of comment-code-save-load in mind.
Often, profile changes that make sense at the time unintelligible when you review them later.
Comments help you keep track of what you’re doing and can prompt ideas about how to better organize your profile as you continue customizing it.</p>

<h2 id="shell-prompts">Shell Prompts</h2>

<p>One of the obvious changes between shells is the information presented to you at the prompt.
Using <code class="language-plaintext highlighter-rouge">sh</code>, the default prompt is <code class="language-plaintext highlighter-rouge">sh-3.2$</code>.
Using <code class="language-plaintext highlighter-rouge">bash</code>, the default prompt is <code class="language-plaintext highlighter-rouge">bash-3.2$</code>.</p>

<p>It’s nice to know the shell and the version number, but maybe there’s more useful information.
For example, I have made the following customization to my <code class="language-plaintext highlighter-rouge">zsh</code> prompt.</p>

<ul>
  <li>A status indicator that says if the last command completed as expected (√ in green) or had an error (? in red)</li>
  <li>The name of the current working directory in bold to remind me where I am</li>
  <li>A percent sign instead of dollar sign as my delimiter because it looks nicer to me</li>
  <li>A timestamp on the right side of the terminal to keep track of when the last process completed</li>
</ul>

<p>There are many ways to customize your prompt.
Each depends on the shell and sometimes it requires additional programs.
And often, the syntax for these customizations is cryptic.
To accomplish the above customizations on a base install of <code class="language-plaintext highlighter-rouge">zsh</code>, I added the following to my profile after cribbing a lot of examples.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Configure ZSH prompt</span>
</code></pre></div></div>

<p>I understand this enough to tweak aspects of it, but not enough to really change it.
My advice is to start from what other people have shared online and keep your configuration simple.</p>
