<h2 id="goals">Goals</h2>

<ul>
  <li>Learn how to mock files and directories for testing purposes</li>
  <li>Use the features of <code class="language-plaintext highlighter-rouge">pathlib</code> to create and manipulate paths</li>
</ul>

<h2 id="path-requirements">Path requirements</h2>

<p><code class="language-plaintext highlighter-rouge">filetransfer.py</code> will need to</p>

<ul>
  <li>Read the source digital carrier</li>
  <li>Create a destination based on the Media ID</li>
</ul>

<p>Let’s think about these as tests.</p>

<ul>
  <li>Confirm that that source digital carrier exists</li>
  <li>Confirm that the destination parent directory exists</li>
  <li>Confirm that the destination based on the Media ID doesn’t already exist</li>
  <li>Confirm that we can create the destination</li>
</ul>

<p>All of these require working with paths.</p>

<h2 id="paths-in-digital-preservation">Paths in Digital Preservation</h2>

<p>Our work always come back to files.
Finding files.
Moving files.
Reading files.
Creating files.
Deleting files.</p>

<p>Our scripts need to be able to work with files scattered across local storage, network storage, external storage, and other systems.
Our desktop computers hide this physical complexity by organizing files according to a hierarchal system of folders.
A file is contained in a folder, which is contained in a folder, and so on until you reach the root folder (Mac/Linux) or drive (Windows).
The series of folders is called the path.</p>

<p>When you use a graphical file manager or a file open dialog, the program constructs the path as you open folders.
That metaphor hides more complexity.
When you open a folder, the contents are listed and you learn what the folder contains.
When you open a further folder, the program updates its current working path by adding that folder to the path.
In Python, we often have to perform these steps explicitly.</p>

<p>And because Python scripts can work on Windows, Linux, and Mac, we also have to be aware of how paths differ between those systems.</p>

<h2 id="filepath-strategies-in-python">Filepath strategies in Python</h2>

<p>If you’ve worked with files in Python before, you might have written lines like <code class="language-plaintext highlighter-rouge">'C:\path\to\directory' + '\' + 'filename'</code> + <code class="language-plaintext highlighter-rouge">open('/path/to/network/drive/report.csv')</code>.
These strings look like paths, and Python functions that work with files can interpret them as path.
Working with paths as just strings does create some problems.
The most visible is that the direction of the slashes (<code class="language-plaintext highlighter-rouge">\</code> or <code class="language-plaintext highlighter-rouge">/</code>) depends on the platform.
That is annoying, although if you work in a single-platform office, it might not come up.</p>

<p>Less obvious is that this encourages hard-coding paths.
The network drive might be mounted as <code class="language-plaintext highlighter-rouge">'/Volumes/network_folder'</code> on one machine but <code class="language-plaintext highlighter-rouge">'/Users/username/Desktop/network_folder'</code> on another.
It would be nice if our script could work on both machines without us having to maintain two different versions of the script.</p>

<p>We’ll use a few strategies to manage these situations.
These will include using one of the standard modules for path manipulation and defining our paths as user input.</p>

<h3 id="ospath-and-pathlib"><code class="language-plaintext highlighter-rouge">os.path</code> and <code class="language-plaintext highlighter-rouge">pathlib</code></h3>

<p>There are two standard modules that you can use to manipulate filepaths, <code class="language-plaintext highlighter-rouge">os</code> and <code class="language-plaintext highlighter-rouge">pathlib</code>.
<code class="language-plaintext highlighter-rouge">os</code> is for operating system interactions, including but not limited to filepaths.
Most of the filename functionality is actually in its <code class="language-plaintext highlighter-rouge">path</code> submodule
<code class="language-plaintext highlighter-rouge">pathlib</code> is a newer module that is only for working with paths.</p>

<p>Both detect the platform they are on, and create a path to that follows the rules of that platform.
The following demonstrates how to join together folder and filenames with each module.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>

<span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">'path'</span><span class="p">,</span> <span class="s">'to'</span><span class="p">,</span> <span class="s">'directory'</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pathlib</span>

<span class="n">path</span> <span class="o">=</span> <span class="n">pathlib</span><span class="p">.</span><span class="n">Path</span><span class="p">(</span><span class="s">'path'</span><span class="p">,</span> <span class="s">'to'</span><span class="p">,</span> <span class="s">'directory'</span><span class="p">)</span>
</code></pre></div></div>

<p>The code looks very similar, but result is different.
<code class="language-plaintext highlighter-rouge">os.path</code> returns a string, <code class="language-plaintext highlighter-rouge">'path/to/directory'</code>.
<code class="language-plaintext highlighter-rouge">pathlib.Path</code> returns a <code class="language-plaintext highlighter-rouge">Path()</code> object, <code class="language-plaintext highlighter-rouge">Path('path/to/directory')</code>.
The following illustrates the difference.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">'path'</span><span class="p">,</span> <span class="s">'to'</span><span class="p">,</span> <span class="s">'directory'</span><span class="p">)</span>
<span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">'filename'</span><span class="p">))</span>
<span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">is_file</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pathlib</span>

<span class="n">path</span> <span class="o">=</span> <span class="n">pathlib</span><span class="p">.</span><span class="n">Path</span><span class="p">(</span><span class="s">'path'</span><span class="p">,</span> <span class="s">'to'</span><span class="p">,</span> <span class="s">'directory'</span><span class="p">)</span>
<span class="n">filepath</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s">'filename'</span><span class="p">)</span>
<span class="n">filepath</span><span class="p">.</span><span class="n">is_fileF</span><span class="p">()</span>
</code></pre></div></div>

<p>Because the result of <code class="language-plaintext highlighter-rouge">os.path</code> manipulations is a string, everytime we use it, we have to call first call a function, and then give it data.
Because the result of <code class="language-plaintext highlighter-rouge">pathlib</code> manipulations is a <code class="language-plaintext highlighter-rouge">Path()</code> object, every object has built-in functions that relate to it being a path.</p>

<p>We will be using <code class="language-plaintext highlighter-rouge">pathlib</code>.
Since it is newer, you may not find as many posts and articles for it on the Internet.
In those cases, you can always use ideas from <code class="language-plaintext highlighter-rouge">os.path</code> but you’ll need to translate to the <code class="language-plaintext highlighter-rouge">pathlib</code> syntax.</p>

<h3 id="mocking-file-paths">Mocking file paths</h3>

<p>If we’re trying to test code that works with files, how do we test it?
Especially if the script moves or deletes files, how do we makes sure it is not going to run amok?
Mocking.</p>

<p>The mock features of a <code class="language-plaintext highlighter-rouge">pytest</code> can also create temporary files and folders so we can understand if our script’s logic works without risking the files we care about.
To mock a file with <code class="language-plaintext highlighter-rouge">pytest</code>, use the <code class="language-plaintext highlighter-rouge">tmp_path</code> argument.
<code class="language-plaintext highlighter-rouge">tmp_path</code> actually builds off of the <code class="language-plaintext highlighter-rouge">pathlib</code> library.
All of the methods we’ll use to manipulate these temporary paths can also be used with <code class="language-plaintext highlighter-rouge">pathlib</code> paths.</p>

<p>The following tests both the existence of the temporary directory and that it is empty.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_empty_dir</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">):</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">.</span><span class="n">iterdir</span><span class="p">())</span>
    <span class="k">assert</span> <span class="n">tmp_path</span><span class="p">.</span><span class="n">exists</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></div></div>

<p>We can also create folders with specific names.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_mddir_created</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">):</span>
    <span class="n">md_dir</span> <span class="o">=</span> <span class="n">tmp_path</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s">'metadata'</span><span class="p">)</span>
    <span class="n">md_dir</span><span class="p">.</span><span class="n">mkdir</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">md_dir</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">'metadata'</span>
</code></pre></div></div>

<p>However, it would be annoying if we had to start every single test with by mocking files and folders.
To simplify this, we can mock the file structure once and tell <code class="language-plaintext highlighter-rouge">pytest</code> to continually reuse that file structure.</p>

<p>The key portions to note here are:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">@pytest.fixture()</code> is a decorator that tells Python to use the following function as a <code class="language-plaintext highlighter-rouge">pytest.fixture</code></li>
  <li><code class="language-plaintext highlighter-rouge">destination_md()</code> returns a value we can use in future functions</li>
  <li>The name of the function <code class="language-plaintext highlighter-rouge">destination_md</code> is passed as an argument to tests that need to used it</li>
</ol>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">pytest</span><span class="p">.</span><span class="n">fixture</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">destination_md</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">):</span>
    <span class="n">md_dir</span> <span class="o">=</span> <span class="n">tmp_path</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s">'metadata'</span><span class="p">)</span>
    <span class="n">md_dir</span><span class="p">.</span><span class="n">mkdir</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">md_dir</span>

<span class="k">def</span> <span class="nf">test_empty_dir</span><span class="p">(</span><span class="n">destination_md</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">destination_md</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">'metadata'</span>

<span class="k">def</span> <span class="nf">test_mddir_created</span><span class="p">(</span><span class="n">destination_md</span><span class="p">):</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">destination_md</span><span class="p">.</span><span class="n">iterdir</span><span class="p">())</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></div></div>

<h2 id="making-sure-paths-exist">Making sure paths exist</h2>

<p>This script works with two storage locations: the source digital carrier and the destination for the bag.
In order for the script to work, both have to exist.
As an extra feature, it would be nice to have a default destination that we can change if needed.</p>

<p>In the previous lesson, we added features to <code class="language-plaintext highlighter-rouge">parse_args</code> to accomplish this.
We will do the same for these arguments, but use file mocking to test if they work.</p>

<h3 id="testing-for-a-bad-carrier-path">Testing for a bad carrier path</h3>

<p>This test can follow the same template as the Media ID validation.
Because we are testing for a non-existant path, we don’t have to mock one up, yet.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_bad_id</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
    <span class="p">...</span>

<span class="k">def</span> <span class="nf">test_bad_carrier_path</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
  <span class="n">bad_path</span> <span class="o">=</span><span class="s">'path/to/carrier'</span>
  <span class="n">monkeypatch</span><span class="p">.</span><span class="nb">setattr</span><span class="p">(</span><span class="s">'sys.argv'</span><span class="p">,</span> <span class="p">[</span><span class="s">'filetransfer.py'</span><span class="p">,</span> <span class="s">'--source'</span><span class="p">,</span> <span class="n">bad_path</span><span class="p">,</span> <span class="s">'--id'</span><span class="p">,</span> <span class="s">'M12345-0001'</span><span class="p">])</span>

  <span class="k">with</span> <span class="n">pytest</span><span class="p">.</span><span class="n">raises</span><span class="p">(</span><span class="nb">SystemExit</span><span class="p">):</span>
    <span class="n">filetransfer</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>

  <span class="n">stderr</span> <span class="o">=</span> <span class="n">capsys</span><span class="p">.</span><span class="n">readouterr</span><span class="p">().</span><span class="n">err</span>

  <span class="k">assert</span> <span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">bad_path</span><span class="si">}</span><span class="s"> does not exist'</span> <span class="ow">in</span> <span class="n">stderr</span>
</code></pre></div></div>

<p>Run <code class="language-plaintext highlighter-rouge">pytest</code> and there should be a new fail.</p>

<h3 id="validating-the-carrier-path">Validating the carrier path</h3>

<p>The <code class="language-plaintext highlighter-rouge">valid_id</code> code from the previous lesson can also act as a template for validating the carrier path.
In <code class="language-plaintext highlighter-rouge">valid_id</code>, we used the <code class="language-plaintext highlighter-rouge">re</code> module to test if the input matches our requirement and then return the input if it does.
That function is then referenced in the appropriate <code class="language-plaintext highlighter-rouge">.add_argument()</code> by <code class="language-plaintext highlighter-rouge">type=valid_id</code>.</p>

<p>We will write a function that similarly tests the input.
In this case, we’ll use the <code class="language-plaintext highlighter-rouge">Path</code> class from the <code class="language-plaintext highlighter-rouge">pathlib</code> module.
Every <code class="language-plaintext highlighter-rouge">Path</code> object has an <code class="language-plaintext highlighter-rouge">.exists()</code> method that will tell you if the path exists or not.
More specifically, it has methods like <code class="language-plaintext highlighter-rouge">.is_dir()</code>, <code class="language-plaintext highlighter-rouge">.is_file()</code>, and others that will tell you if the path is a specific kind of object.</p>

<p>It may feel strange that there can be paths that don’t exist.
But, paths are strings of characters that follow particular rules.
They don’t need to refer to files or folders that exist.
For example, <code class="language-plaintext highlighter-rouge">/path/i/just/made/up</code> is a valid path.
It probably does not exist on your computer, but <code class="language-plaintext highlighter-rouge">pathlib</code> will parse that it is an absolute path, on a Mac/Linux system, with four folders (<code class="language-plaintext highlighter-rouge">path</code>, <code class="language-plaintext highlighter-rouge">i</code>, <code class="language-plaintext highlighter-rouge">just</code>, <code class="language-plaintext highlighter-rouge">made</code>), and a final object that is probably a file or a folder (<code class="language-plaintext highlighter-rouge">up</code>).
If we want this path to exist, we will need to create each component of this path.
We’ll do that later in this lesson.</p>

<p><code class="language-plaintext highlighter-rouge">pathlib.Path</code> objects have lots of useful methods.
While <code class="language-plaintext highlighter-rouge">valid_id</code> tested the input string and returned a string, it would be nice if our function for paths could do 3 things.</p>

<ol>
  <li>parse the input as a <code class="language-plaintext highlighter-rouge">Path</code></li>
  <li>check if the path exists</li>
  <li>return the <code class="language-plaintext highlighter-rouge">Path</code> object so we don’t have to parse it again</li>
</ol>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="k">def</span> <span class="nf">parse_args</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">valid_id</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
        <span class="p">...</span>

    <span class="k">def</span> <span class="nf">extant_dir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="n">parsed_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">).</span><span class="n">is_dir</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parsed_path</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">argparse</span><span class="p">.</span><span class="n">ArgumentTypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">parsed_path</span><span class="si">}</span><span class="s"> does not exist'</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">parsed_path</span>


    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="n">ArgumentParser</span><span class="p">(</span>
        <span class="n">description</span><span class="o">=</span><span class="s">'transfer files from a carrier into a bag'</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s">'--source'</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s">'path to the digital carrier'</span>
        <span class="n">required</span><span class="o">=</span><span class="bp">True</span>
        <span class="nb">type</span><span class="o">=</span><span class="n">extant_dir</span>
    <span class="p">)</span>
</code></pre></div></div>

<p>Run <code class="language-plaintext highlighter-rouge">pytest</code> and… there are 2 failures?</p>

<p>This demonstrates how small assumptions can start creeping into code.
Let’s look at the failures.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>E   argparse.ArgumentError: argument <span class="nt">--source</span>: path/to/source does not exist
</code></pre></div></div>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>E   AssertionError: assert <span class="s1">'N12345-0001 does not match the required Media ID format of M#####-####'</span> <span class="k">in</span> <span class="s1">'usage: filetransfer.py [-h] --source SOURCE --id ID\nfiletransfer.py: error: argument --source: path/to/source does not exist\n'</span>
</code></pre></div></div>

<p>Now that code is checking to make sure a source exists, any test that we wrote with a non-existent path fails.
These are good fails.
What we need to do is update our tests to use paths that exist.</p>

<p>At the top of the testing script we can create a file fixture.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">filetransfer</span>
<span class="kn">import</span> <span class="nn">pytest</span>

<span class="c1"># Fixtures
</span><span class="o">@</span><span class="n">pytest</span><span class="p">.</span><span class="n">fixture</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">source_dir</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tmp_path</span>
</code></pre></div></div>

<p>And in each of our failing tests, we add <code class="language-plaintext highlighter-rouge">source_dir</code> as input and replace the hard-coded non-existent file path with the new fixture.
Note that sometimes we have to explicitly ask for the string representation of the path, like in the <code class="language-plaintext highlighter-rouge">sys.argv</code> mock.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_required_args</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">,</span> <span class="n">source_dir</span><span class="p">):</span>
    <span class="n">monkeypatch</span><span class="p">.</span><span class="nb">setattr</span><span class="p">(</span><span class="s">'sys.argv'</span><span class="p">,</span> <span class="p">[</span><span class="s">'filetransfer.py'</span><span class="p">,</span> <span class="s">'--source'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">source_dir</span><span class="p">),</span> <span class="s">'--id'</span><span class="p">,</span> <span class="s">'M12345-0001'</span><span class="p">])</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">filetransfer</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">args</span><span class="p">.</span><span class="n">source</span> <span class="o">==</span> <span class="n">source_dir</span>
    <span class="k">assert</span> <span class="n">args</span><span class="p">.</span><span class="nb">id</span> <span class="o">==</span> <span class="s">'M12345-0001'</span>
</code></pre></div></div>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_bad_id</span><span class="p">(</span><span class="n">capsys</span><span class="p">,</span> <span class="n">monkeypatch</span><span class="p">,</span> <span class="n">source_dir</span><span class="p">):</span>
    <span class="n">bad_id</span> <span class="o">=</span><span class="s">'N12345-0001'</span>
    <span class="n">monkeypatch</span><span class="p">.</span><span class="nb">setattr</span><span class="p">(</span><span class="s">'sys.argv'</span><span class="p">,</span> <span class="p">[</span><span class="s">'filetransfer.py'</span><span class="p">,</span> <span class="s">'--source'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">source_dir</span><span class="p">),</span> <span class="s">'--id'</span><span class="p">,</span> <span class="n">bad_id</span><span class="p">])</span>

    <span class="k">with</span> <span class="n">pytest</span><span class="p">.</span><span class="n">raises</span><span class="p">(</span><span class="nb">SystemExit</span><span class="p">):</span>
        <span class="n">filetransfer</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="n">stderr</span> <span class="o">=</span> <span class="n">capsys</span><span class="p">.</span><span class="n">readouterr</span><span class="p">().</span><span class="n">err</span>

    <span class="k">assert</span> <span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">bad_id</span><span class="si">}</span><span class="s"> does not match the required Media ID format of M#####-####'</span> <span class="ow">in</span> <span class="n">stderr</span>
</code></pre></div></div>

<p>Run <code class="language-plaintext highlighter-rouge">pytest</code> and there should be 6 passes.</p>

<h3 id="testing-for-an-available-and-writeable-destination">Testing for an available and writeable destination</h3>

<p>This requirement feels very similar to the previous, and we’ll follow a lot of the same template.</p>

<p>First for the mock file structure, add a fixture to create a destination fixture.
We are using tmp_path, but this will create a new directory separate from source_dir.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">source_dir</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">):</span>
    <span class="p">...</span>

<span class="o">@</span><span class="n">pytest</span><span class="p">.</span><span class="n">fixture</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">dest_dir</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tmp_path</span>
</code></pre></div></div>

<p>Back at the bottom of the script, create a test for a non-existent destination directory.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_bad_carrier_path</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
    <span class="p">...</span>

<span class="k">def</span> <span class="nf">test_non_existant_destination_path</span><span class="p">(</span><span class="n">capsys</span><span class="p">,</span> <span class="n">monkeypatch</span><span class="p">,</span> <span class="n">source_dir</span><span class="p">):</span>
    <span class="n">bad_path</span> <span class="o">=</span> <span class="s">'path/to/dest'</span>
    <span class="n">monkeypatch</span><span class="p">.</span><span class="nb">setattr</span><span class="p">(</span><span class="s">'sys.argv'</span><span class="p">,</span>
        <span class="p">[</span>
            <span class="s">'filetransfer.py'</span><span class="p">,</span>
            <span class="s">'--source'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">source_dir</span><span class="p">),</span>
            <span class="s">'--id'</span><span class="p">,</span> <span class="s">'M12345-0001'</span><span class="p">,</span>
            <span class="s">'--dest'</span><span class="p">,</span> <span class="n">bad_path</span>
        <span class="p">])</span>

    <span class="k">with</span> <span class="n">pytest</span><span class="p">.</span><span class="n">raises</span><span class="p">(</span><span class="nb">SystemExit</span><span class="p">):</span>
        <span class="n">filetransfer</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="n">stderr</span> <span class="o">=</span> <span class="n">capsys</span><span class="p">.</span><span class="n">readouterr</span><span class="p">().</span><span class="n">err</span>

    <span class="k">assert</span> <span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">bad_path</span><span class="si">}</span><span class="s"> does not exist'</span> <span class="ow">in</span> <span class="n">stderr</span>
</code></pre></div></div>

<p>Run <code class="language-plaintext highlighter-rouge">pytest</code> and there should be 1 failed test.
The expected error didn’t happen.</p>

<p>Next create a similar test for if the destination is writable.
We will use the same fixture and alter the readability of it for just this test by using the <code class="language-plaintext highlighter-rouge">.chmod()</code> method.</p>

<p><code class="language-plaintext highlighter-rouge">.chmod()</code> replicates the <code class="language-plaintext highlighter-rouge">chmod</code> shell tool, which is used to set the read, write, and execute permissions for 3 kinds of users.
Those characteristics are set by a set of 3 numbers, each between 0 and 7.
We supply those numbers to <code class="language-plaintext highlighter-rouge">chmod()</code> in Python by first indicating that these are octal (<code class="language-plaintext highlighter-rouge">0o</code>).
To make a folder readable and executeable but non-writeable for all users, use <code class="language-plaintext highlighter-rouge">0o555</code>
Read up on <a href="https://en.wikipedia.org/wiki/Chmod">chmod</a> for more information.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_non_existant_destination_path</span><span class="p">(</span><span class="n">capsys</span><span class="p">,</span> <span class="n">monkeypatch</span><span class="p">,</span> <span class="n">source_dir</span><span class="p">):</span>
    <span class="p">...</span>

<span class="k">def</span> <span class="nf">test_non_writable_destination_path</span><span class="p">(</span><span class="n">capsys</span><span class="p">,</span> <span class="n">monkeypatch</span><span class="p">,</span> <span class="n">source_dir</span><span class="p">,</span> <span class="n">dest_dir</span><span class="p">):</span>
    <span class="n">dest_dir</span><span class="p">.</span><span class="n">chmod</span><span class="p">(</span><span class="mo">0o555</span><span class="p">)</span>
    <span class="n">monkeypatch</span><span class="p">.</span><span class="nb">setattr</span><span class="p">(</span><span class="s">'sys.argv'</span><span class="p">,</span>
        <span class="p">[</span>
            <span class="s">'filetransfer.py'</span><span class="p">,</span>
            <span class="s">'--source'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">source_dir</span><span class="p">),</span>
            <span class="s">'--id'</span><span class="p">,</span> <span class="s">'M12345-0001'</span><span class="p">,</span>
            <span class="s">'--dest'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">dest_dir</span><span class="p">)</span>
        <span class="p">])</span>

    <span class="k">with</span> <span class="n">pytest</span><span class="p">.</span><span class="n">raises</span><span class="p">(</span><span class="nb">SystemExit</span><span class="p">):</span>
        <span class="n">filetransfer</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="n">stderr</span> <span class="o">=</span> <span class="n">capsys</span><span class="p">.</span><span class="n">readouterr</span><span class="p">().</span><span class="n">err</span>

    <span class="k">assert</span> <span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">bad_path</span><span class="si">}</span><span class="s"> is not writable. Check your permissions'</span> <span class="ow">in</span> <span class="n">stderr</span>
</code></pre></div></div>

<p>Run <code class="language-plaintext highlighter-rouge">pytest</code> and there should be 2 fails.</p>

<h3 id="accepting-and-validating-a-destination">Accepting and validating a destination</h3>

<p>In order to raise the expected errors, the parser needs to work with the <code class="language-plaintext highlighter-rouge">--dest</code> argument in the tests.
You could argue that we should have written an additional test or updated an existing test for successfully accepting this argument.
You’re probably right, as we’ll soon see.</p>

<p>For now, let’s add the new argument.
Instead of making it required, we will use a new feature, <code class="language-plaintext highlighter-rouge">default</code>.
It will also use the same validation function as the <code class="language-plaintext highlighter-rouge">source</code> argument.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parse_args</span><span class="p">():</span>
    <span class="p">...</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s">'--id'</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s">'media id in the form of M#####-####'</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="n">valid_id</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s">'--dest'</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s">'path to destination'</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="s">'/Volumes/DigArchDiskStation/'</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="n">extant_dir</span>
    <span class="p">)</span>
</code></pre></div></div>

<p>Run <code class="language-plaintext highlighter-rouge">pytest</code> and there should be 3 failed test.
<code class="language-plaintext highlighter-rouge">test_non_existent_destination_path</code> should be passing as expected.
<code class="language-plaintext highlighter-rouge">test_non_writable_destination_path</code> should still be failing as expected.
<code class="language-plaintext highlighter-rouge">test_require_args</code> and <code class="language-plaintext highlighter-rouge">test_missing_args</code> are failing.</p>

<p>That’s not because there are new requirements, but because the default <code class="language-plaintext highlighter-rouge">dest</code> argument is failing its validation.
<code class="language-plaintext highlighter-rouge">error: argument --dest: /Volumes/DigArchDiskStation does not exist</code>
That’s a good fail, again.
It’s an annoying failure, because it’s less clear how to handle this issue.</p>

<ol>
  <li>Update the failing test to use the <code class="language-plaintext highlighter-rouge">dest_dir</code> fixture. (easiest)</li>
  <li>Update the failing tests to ignore the <code class="language-plaintext highlighter-rouge">dest</code> validation. (more complicated, may cause its own bugs)</li>
  <li>Use a fixture to create a directory at the default path. (dangerous if that’s our production path)</li>
  <li>Another strategy that a more experienced programmer know about.</li>
</ol>

<p>This is one of the frustrations of unit testing as a non-professional programmer.
The more training you have, the better you are able to create tests systematically.
But we don’t have that intuition or knowledge, so it’s hard to know if we’re over-testing, under-testing, or testing the wrong things.
This inexpert-programming author isn’t sure where the balance exists either. <code class="language-plaintext highlighter-rouge">¯\_(ツ)_/¯</code></p>

<p>For now, let’s use the first strategy.
It does dilute the purpose of those tests.
However, it most directly addresses our issue.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_required_args</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">,</span> <span class="n">source_dir</span><span class="p">,</span> <span class="n">dest_dir</span><span class="p">):</span>
    <span class="n">monkeypatch</span><span class="p">.</span><span class="nb">setattr</span><span class="p">(</span><span class="s">'sys.argv'</span><span class="p">,</span>
        <span class="p">[</span>
            <span class="s">'filetransfer.py'</span><span class="p">,</span>
            <span class="s">'--source'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">source_dir</span><span class="p">),</span>
            <span class="s">'--id'</span><span class="p">,</span> <span class="s">'M12345-0001'</span><span class="p">,</span>
            <span class="s">'--dest'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">dest_dir</span><span class="p">)</span>
        <span class="p">])</span>
    <span class="p">...</span>


<span class="k">def</span> <span class="nf">test_missing_args</span><span class="p">(</span><span class="n">capsys</span><span class="p">,</span> <span class="n">monkeypatch</span><span class="p">,</span> <span class="n">dest_dir</span><span class="p">):</span>
    <span class="n">monkeypatch</span><span class="p">.</span><span class="nb">setattr</span><span class="p">(</span><span class="s">'sys.argv'</span><span class="p">,</span> <span class="p">[</span><span class="s">'filetransfer.py'</span><span class="p">,</span> <span class="s">'--dest'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">dest_dir</span><span class="p">)])</span>
    <span class="p">...</span>
</code></pre></div></div>

<p>Run <code class="language-plaintext highlighter-rouge">pytest</code> and there should only be 1 failed test.
Let’s address that.</p>

<p>Unfortunately, <code class="language-plaintext highlighter-rouge">pathlib</code> does not have a method for checking writability.
We will need to use the <a href="https://docs.python.org/3/library/os.html#os.access"><code class="language-plaintext highlighter-rouge">os.access</code> function</a> for this.
The testing template is the same.
In this case, the test will be <code class="language-plaintext highlighter-rouge">os.access(path/to/dir, os.W_OK)</code></p>

<p>We used the type argument to test the existence of the file.
We can only use that argument once.
If we add a writability test to the <code class="language-plaintext highlighter-rouge">extant_dir</code>, that would also affect <code class="language-plaintext highlighter-rouge">source</code> arguments.
Instead, we can wrap <code class="language-plaintext highlighter-rouge">extant_dir</code> inside of another function.</p>

<p>Then</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="p">...</span>

    <span class="k">def</span> <span class="nf">extant_dir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="p">...</span>

    <span class="k">def</span> <span class="nf">writable_path</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="n">parsed_path</span> <span class="o">=</span> <span class="n">extant_dir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="p">.</span><span class="n">access</span><span class="p">(</span><span class="n">parsed_path</span><span class="p">,</span> <span class="n">os</span><span class="p">.</span><span class="n">W_OK</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">argparse</span><span class="p">.</span><span class="n">ArgumentTypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">parsed_path</span><span class="si">}</span><span class="s"> is not writeable. Check your permissions.'</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">parsed_path</span>
</code></pre></div></div>

<p>Run <code class="language-plaintext highlighter-rouge">pytest</code>. There should be 8 passes.</p>

<h2 id="creating-the-destination-directory">Creating the destination directory</h2>

<p>All of this work, and we’ve only defined inputs.
We haven’t done anything with any data so far.
Then again, that is a lot of digital curation work.
We rely on specialized tools that do very complicated things.
Our expertise is in supplying the right inputs to those tools to make sure they perform the work we expect.</p>

<p>Now that we’re confident in our inputs, we can use that data to perform some work.
For example, if we know the destination directory and Media ID, we can create the correct folders in preparation for the file transfer.</p>

<p>In our case, those folders are</p>

<ol>
  <li>a parent folder for the collection</li>
  <li>a parent folder named by the Media ID</li>
  <li>a child folder named <code class="language-plaintext highlighter-rouge">objects</code> that will receive the transferred files</li>
  <li>a child folder name <code class="language-plaintext highlighter-rouge">metadata</code> with a second child folder named <code class="language-plaintext highlighter-rouge">submissionDocumentation</code> that receives reports and logs about the transferred files</li>
</ol>

<p>We also don’t want to overwrite these folders if they already exist.</p>

<h3 id="testing-for-creating-folders">Testing for creating folders</h3>

<p>We need a function to create the directories.
We’ll call this <code class="language-plaintext highlighter-rouge">create_dirs</code>.
It will take two arguments, the destination directory and the Media ID.
It will create our required folders and return the path to the <code class="language-plaintext highlighter-rouge">objects</code> folder.</p>

<p>Our test will need to</p>

<ul>
  <li>define the paths that should be created</li>
  <li>run the <code class="language-plaintext highlighter-rouge">create_dirs</code></li>
  <li>test that the paths exist</li>
  <li>test that the function returns the expected value</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">test_create_directories</span><span class="p">(</span><span class="n">dest_dir</span><span class="p">):</span>
    <span class="n">media_id</span> <span class="o">=</span> <span class="s">'M12345-0001'</span>
    <span class="n">collection</span> <span class="o">=</span> <span class="n">media_id</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'-'</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">coll_dir</span> <span class="o">=</span> <span class="n">dest_dir</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
    <span class="n">id_dir</span> <span class="o">=</span> <span class="n">coll_dir</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">media_id</span><span class="p">)</span>
    <span class="n">object_dir</span> <span class="o">=</span> <span class="n">id_dir</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s">'objects'</span><span class="p">)</span>
    <span class="n">subDoc_dir</span> <span class="o">=</span> <span class="n">id_dir</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s">'metadata'</span><span class="p">).</span><span class="n">joinpath</span><span class="p">(</span><span class="s">'submissionDocumentation'</span><span class="p">)</span>

    <span class="n">returned_object_dir</span> <span class="o">=</span> <span class="n">filetransfer</span><span class="p">.</span><span class="n">create_dirs</span><span class="p">(</span><span class="n">dest_dir</span><span class="p">,</span> <span class="n">media_id</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">object_dir</span><span class="p">.</span><span class="n">exists</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">subDoc_dir</span><span class="p">.</span><span class="n">exists</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">object_dir</span> <span class="o">==</span> <span class="n">returned_object_dir</span>
</code></pre></div></div>

<p>We only test for the existence of two directories because if they exist, so do their parent directories.</p>

<h3 id="writing-create_dirs">Writing <code class="language-plaintext highlighter-rouge">create_dirs</code></h3>

<p>The logic for creating the test can be transferred over to the function.
It will need to:</p>

<ul>
  <li>receive two arguments as input</li>
  <li>define the paths to be created</li>
  <li>return the one of the paths as output</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">create_dirs</span><span class="p">(</span><span class="n">parent_dir</span><span class="p">,</span> <span class="n">media_id</span><span class="p">):</span>
    <span class="n">collection</span> <span class="o">=</span> <span class="n">media_id</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'-'</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">coll_dir</span> <span class="o">=</span> <span class="n">parent_dir</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
    <span class="n">id_dir</span> <span class="o">=</span> <span class="n">coll_dir</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">media_id</span><span class="p">)</span>
    <span class="n">object_dir</span> <span class="o">=</span> <span class="n">id_dir</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s">'objects'</span><span class="p">)</span>
    <span class="n">subDoc_dir</span> <span class="o">=</span> <span class="n">id_dir</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s">'metadata'</span><span class="p">).</span><span class="n">joinpath</span><span class="p">(</span><span class="s">'submissionDocumentation'</span><span class="p">)</span>

    <span class="n">object_dir</span><span class="p">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">subDoc_dir</span><span class="p">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">object_dir</span>
</code></pre></div></div>

<p>This code looks very similar to the test.
As we write further tests, it will start looking different.</p>

<p>Much like <code class="language-plaintext highlighter-rouge">.exists()</code> also checks the existence of parent folders, <code class="language-plaintext highlighter-rouge">.mkdir()</code> can create parent folders by using the argument <code class="language-plaintext highlighter-rouge">parents=True</code>.</p>

<p>Run <code class="language-plaintext highlighter-rouge">pytest</code> and the test should be passing.</p>

<h3 id="testing-against-overwrites">Testing against overwrites</h3>

<p>The test to make sure <code class="language-plaintext highlighter-rouge">create_dirs</code> raises an exception follows the logic of the test for the unwritable destination.
First create the situation in the mock file system, then see if the correct error is raised.</p>

<p>Because the function is supposed to raise an exception, it is wrapped in a <code class="language-plaintext highlighter-rouge">with</code> block much like the system exits for argument parsing.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_do_not_overwrite_transfer</span><span class="p">(</span><span class="n">dest_dir</span><span class="p">):</span>
    <span class="n">media_id</span> <span class="o">=</span> <span class="s">'M12345-0001'</span>
    <span class="n">collection</span> <span class="o">=</span> <span class="n">media_id</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'-'</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">coll_dir</span> <span class="o">=</span> <span class="n">dest_dir</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
    <span class="n">id_dir</span> <span class="o">=</span> <span class="n">coll_dir</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">media_id</span><span class="p">)</span>
    <span class="n">id_dir</span><span class="p">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">pytest</span><span class="p">.</span><span class="n">raises</span><span class="p">(</span><span class="nb">Exception</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="n">returned_object_dir</span> <span class="o">=</span> <span class="n">filetransfer</span><span class="p">.</span><span class="n">create_dirs</span><span class="p">(</span><span class="n">dest_dir</span><span class="p">,</span> <span class="n">media_id</span><span class="p">)</span>

    <span class="k">assert</span> <span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">id_dir</span><span class="si">}</span><span class="s"> already exists, check to make sure you are not overwriting'</span> <span class="ow">in</span> <span class="n">err</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<p>Run <code class="language-plaintext highlighter-rouge">pytest</code> and the failed test will report that no exception is raised.
That means our script would happily overwrite existing work.</p>

<h3 id="improving-create_dirs">Improving <code class="language-plaintext highlighter-rouge">create_dirs</code></h3>

<p>In order to address this issue, <code class="language-plaintext highlighter-rouge">create_dirs</code> should check if the directory exists before creating new directories.
If it does exist, it should raise an exception.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">create_dirs</span><span class="p">(</span><span class="n">parent_dir</span><span class="p">,</span> <span class="n">media_id</span><span class="p">):</span>
    <span class="n">media_id</span> <span class="o">=</span> <span class="s">'M12345-0001'</span>
    <span class="n">collection</span> <span class="o">=</span> <span class="n">media_id</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'-'</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">coll_dir</span> <span class="o">=</span> <span class="n">parent_dir</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
    <span class="n">id_dir</span> <span class="o">=</span> <span class="n">coll_dir</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">media_id</span><span class="p">)</span>
    <span class="n">object_dir</span> <span class="o">=</span> <span class="n">id_dir</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s">'objects'</span><span class="p">)</span>
    <span class="n">subDoc_dir</span> <span class="o">=</span> <span class="n">id_dir</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s">'metadata'</span><span class="p">).</span><span class="n">joinpath</span><span class="p">(</span><span class="s">'submissionDocumentation'</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">id_dir</span><span class="p">.</span><span class="n">exists</span><span class="p">():</span>
        <span class="n">object_dir</span><span class="p">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">subDoc_dir</span><span class="p">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nb">Exception</span><span class="p">(</span>
            <span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">id_dir</span><span class="si">}</span><span class="s"> already exists, check to make sure you are not overwriting'</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">object_dir</span>
</code></pre></div></div>

<h2 id="filepath-conclusion">Filepath Conclusion</h2>

<p>This lesson introduced <code class="language-plaintext highlighter-rouge">pathlib</code> and several of its methods, including <code class="language-plaintext highlighter-rouge">.joinpath()</code>, <code class="language-plaintext highlighter-rouge">.exists()</code>, <code class="language-plaintext highlighter-rouge">.is_dir()</code>, <code class="language-plaintext highlighter-rouge">.chmod()</code>, and <code class="language-plaintext highlighter-rouge">.mkdir()</code>.
It also introduced the file mocking and fixture features of <code class="language-plaintext highlighter-rouge">pytest</code>, which conveniently also used <code class="language-plaintext highlighter-rouge">pathlib</code>.</p>

<p>We were able to use these tools to write code that creates new folders while making sure we don’t overwrite existing folders.</p>
