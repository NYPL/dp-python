<h2 id="goals">Goals</h2>

<ul>
  <li>Document what user input we need to support</li>
  <li>Write tests to check if our script accepts that input</li>
  <li>Build a command-line interface for our script</li>
</ul>

<h2 id="user-input-requirements">User Input Requirements</h2>

<p><code class="language-plaintext highlighter-rouge">ft.sh</code> has two points where it asks for user input.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="k">${</span><span class="nv">BLUE</span><span class="k">}</span><span class="s2">Please drag the SIP folder over this window. See the folder path displayed? Hit return!:</span><span class="k">${</span><span class="nv">NC</span><span class="k">}</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="k">${</span><span class="nv">BLUE</span><span class="k">}</span><span class="s2">Please enter the MediaID for this file transfer and hit return:</span><span class="k">${</span><span class="nv">NC</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>The folder path is an absolute path to the digitial carrier being transferred, such as <code class="language-plaintext highlighter-rouge">/Volumes/mounted-hard-drive</code>
The MediaID is an ID created by NYPL to uniquely identify the carrier.
It consists of the collection number, a dash, and a sequential number for the media in the collection, such as <code class="language-plaintext highlighter-rouge">M123456-0001</code>.
Both of these inputs are required.</p>

<p>Currently, <code class="language-plaintext highlighter-rouge">ft.sh</code> accepts inputs interactively.
First, you run the script.
Then, a prompt appears asking you for a file path.
Then, another prompt appears asking you for a MediaID.
Each of these steps contain a lot of help text.</p>

<p>We’re going to change this behavior and have all user input happen as arguments to the first command, e.g. <code class="language-plaintext highlighter-rouge">filetransfer.py -arg1 /Volumes/mounted-hard-drive -arg2 M123456-0001</code>
This will make it easier to further automate the command in the future since you don’t need to sit at the computer and wait for the prompt.
We’re also going to require both pieces of input, and we’ll have a help interface to explain these features.</p>

<p>So our requirements for the command-line interface are:</p>

<ol>
  <li>Accept a Media ID and a carrier path</li>
  <li>Require both a Media ID and a carrier path to run</li>
  <li>Provide help text</li>
</ol>

<p>Before we build the code to accomplish this, we’ll build the tests to see if we were successful.</p>

<h2 id="writing-tests-for-command-line-input">Writing Tests for Command Line Input</h2>

<p>We need two things to test the command line interface for the script.</p>

<ol>
  <li>A way to refer to the command-line portion of the script from our test script</li>
  <li>A way to for the test script to send command-line arguments</li>
</ol>

<h3 id="functions-and-testing">Functions and Testing</h3>

<p>In order to refer to the command-line portion of the script, we need a name to refer to it.
That’s one of the benefits of creating a function.</p>

<p>The following examples of pseudo-code are roughly equal.
A piece of data is processed by one function, <code class="language-plaintext highlighter-rouge">str</code>, and the result is processed by a second function, <code class="language-plaintext highlighter-rouge">parse</code>.
The final result is stored to a variable called <code class="language-plaintext highlighter-rouge">result</code>.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">variable</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">argument</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

</code></pre></div></div>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parse_args</span><span class="p">(</span><span class="n">argument</span><span class="p">):</span>
  <span class="n">variable</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">argument</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span>

</code></pre></div></div>

<p>The difference is that if we ever need to use that sequence of functions again, the second example let’s us call <code class="language-plaintext highlighter-rouge">function_name(argument)</code> instead of repeating the previous two lines.</p>

<p>When it comes to testing, functions are critical, because they’re the only way that we can test that logic.
The first example above is untestable.
There is no easy way to tell our testing script to run two random lines of code.
And even if we figured one out, we’d have to update that test every time the lines shifted around.
Being able to call <code class="language-plaintext highlighter-rouge">script_name.function_name()</code> makes the code testable.</p>

<p>Once our code has a name, we can write one or more tests to check the behavior of that code.
As we improve the logic inside the function, we should have unit tests that check to make sure it performs the right actions.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_parse_args</span><span class="p">():</span>
  <span class="n">argument</span> <span class="o">=</span> <span class="s">'a known input'</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">script_name</span><span class="p">.</span><span class="n">function_name</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="s">'a known result'</span>

</code></pre></div></div>

<p>If we learn about a new function that runs faster, looks cleaner, or is somehow better than our current implementation, we can update our script and see if it still passes the test.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parse_args</span><span class="p">(</span><span class="n">argument</span><span class="p">):</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">a_better_way_we_just_found_out_about</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span>

</code></pre></div></div>

<p>A more immediate benefit of functions is that they can help break down the logic of a program into discrete chunks.
That gives a nice grouping for the data and functions used to accomplish a particular step.
In this lesson, we’ll create a function for parsing command-line arguments.</p>

<h3 id="mocking">Mocking</h3>

<p>The second thing we need is a way for our test script to act like it’s receiving command-line arguments.
It would be painful if we have to actual input our arguments during a test run.</p>

<p>Having a test perform fake actions for the sake of testing some other functionality is called mocking.
<code class="language-plaintext highlighter-rouge">pytest</code> has a specific version of mocking called <code class="language-plaintext highlighter-rouge">monkeypatch</code>.</p>

<p>To use it, our test function needs to accept <code class="language-plaintext highlighter-rouge">monkeypatch</code> as input.
Then we can use the attributes of <code class="language-plaintext highlighter-rouge">pytest</code>’s <code class="language-plaintext highlighter-rouge">monkeypatch</code> to fake command-line arguments, receiving data from a server, creating files, and other testing conditions.
In Python, command-line arguments are represented by a list called <code class="language-plaintext highlighter-rouge">sys.argv</code>.
Then for our command-line argument tests, we mock <code class="language-plaintext highlighter-rouge">sys.argv</code> with a potential command broken down into a list of strings.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_parse_args</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
  <span class="n">monkeypatch</span><span class="p">.</span><span class="nb">setattr</span><span class="p">(</span><span class="s">'sys.argv'</span><span class="p">,</span> <span class="p">[</span><span class="s">'filetransfer.py'</span><span class="p">,</span> <span class="s">'arg1'</span><span class="p">,</span> <span class="s">'arg2'</span><span class="p">])</span>
  <span class="n">args</span> <span class="o">=</span> <span class="n">filetransfer</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>
  <span class="k">assert</span> <span class="n">arg1</span> <span class="ow">in</span> <span class="n">args</span>
  <span class="k">assert</span> <span class="n">arg2</span> <span class="ow">in</span> <span class="n">args</span>

</code></pre></div></div>

<p>There is some magic happening here that is easier to accept on faith.
<code class="language-plaintext highlighter-rouge">sys.argv</code> is how Python parses terminal inputs.
Those inputs are separated into a list by space characters, e.g. <code class="language-plaintext highlighter-rouge">filetransfer.py arg1 arg2</code> becomes <code class="language-plaintext highlighter-rouge">['filetransfer.py', 'arg1', 'arg2']</code>
The <code class="language-plaintext highlighter-rouge">parse_args</code> method should by default parse terminal defaults.
It’s worth investigating this magic as you get deeper into CLIs, but we’ll get back to our task for now.</p>

<h2 id="writing-cli-tests-for-filetransferpy">Writing CLI Tests for <code class="language-plaintext highlighter-rouge">filetransfer.py</code></h2>

<p>Back to the <code class="language-plaintext highlighter-rouge">test_filetransfer.py</code> script, which looked like this.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">filetransfer</span>
<span class="kn">import</span> <span class="nn">pathlib</span>

<span class="k">def</span> <span class="nf">test_completedtransfer</span><span class="p">():</span>
    <span class="n">filetransfer</span><span class="p">.</span><span class="n">main</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">pathlib</span><span class="p">.</span><span class="n">Path</span><span class="p">(</span><span class="s">'/path/to/destination'</span><span class="p">).</span><span class="n">exists</span><span class="p">()</span>
</code></pre></div></div>

<p>First we’ll add some comments to keep things organized.
Over time, we’ll add additional tests.
It will be easier to read all the tests if they are grouped by purpose</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">filetransfer</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">pytest</span>

<span class="c1"># functional tests
</span><span class="k">def</span> <span class="nf">test_completedtransfer</span><span class="p">():</span>
    <span class="n">filetransfer</span><span class="p">.</span><span class="n">main</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">pathlib</span><span class="p">.</span><span class="n">Path</span><span class="p">(</span><span class="s">'/path/to/destination'</span><span class="p">).</span><span class="n">exists</span><span class="p">()</span>

<span class="c1"># unit tests
# command line tests
</span></code></pre></div></div>

<p>Our CLI should do 3 things.</p>

<ol>
  <li>Accept a Media ID and a carrier path</li>
  <li>Require both a Media ID and a carrier path to run</li>
  <li>Provide help text</li>
</ol>

<p>The loop for writing these tests will be.</p>

<ol>
  <li>Write the test</li>
  <li>Run the test script to make sure it generates a fail and not an error.</li>
  <li>Correct any bugs in the test, in case of an error</li>
  <li>Add and commit the test in version control</li>
</ol>

<h3 id="test-for-accepting-arguments">Test for accepting arguments</h3>

<p>This test brings up one of the hardest tasks in programming, naming things.
We want argument names that are both descriptive but not annoyingly long to type out.
For now, let’s say that the argument name for the media id should be <code class="language-plaintext highlighter-rouge">--id</code> and for the path should be <code class="language-plaintext highlighter-rouge">--source</code>.
A run of this script would be <code class="language-plaintext highlighter-rouge">python filetransfer.py python filetransfer.py --source path/to/source --id M12345-0001</code>.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># unit tests
# command line tests
</span>
<span class="k">def</span> <span class="nf">test_required_args</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
  <span class="n">monkeypatch</span><span class="p">.</span><span class="nb">setattr</span><span class="p">(</span><span class="s">'sys.argv'</span><span class="p">,</span> <span class="p">[</span><span class="s">'filetransfer.py'</span><span class="p">,</span> <span class="s">'--source'</span><span class="p">,</span> <span class="s">'path/to/source'</span><span class="p">,</span> <span class="s">'--id'</span><span class="p">,</span> <span class="s">'M12345-0001'</span><span class="p">])</span>
  <span class="n">args</span> <span class="o">=</span> <span class="n">filetransfer</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>
  <span class="k">assert</span> <span class="n">args</span><span class="p">.</span><span class="n">source</span> <span class="o">==</span> <span class="s">'path/to/source'</span>
  <span class="k">assert</span> <span class="n">args</span><span class="p">.</span><span class="nb">id</span> <span class="o">==</span> <span class="s">'M12345-0001'</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">args</code> is a fairly common abbreviation for arguments.
The <code class="language-plaintext highlighter-rouge">args.argument_name</code> syntax is also a common method to handle command-line arguments, based partially on the module we’ll use to do the parsing.</p>

<h3 id="require-both-arguments">Require both arguments</h3>

<p>Our CLI should also give feedback if a user forgets to include an argument or has a typo in their argument.
To mock this, we’ll act like the user only ran <code class="language-plaintext highlighter-rouge">python filetransfer.py</code>.
In this situation, we want the script to immediately exit and report that both the <code class="language-plaintext highlighter-rouge">source</code> argument and the <code class="language-plaintext highlighter-rouge">id</code> argument are missing.</p>

<p>When a tested Python function exits, the function doing the testing also exits.
In order to examine and test the behavior during the exit, we have to run the tested function in a special context that does not cause the testing function to exit.
In <code class="language-plaintext highlighter-rouge">pytest</code>, this is done using a <code class="language-plaintext highlighter-rouge">with pytest.raises(SystemExit):</code> block.
We also need something that captures the error reporting.
In <code class="language-plaintext highlighter-rouge">pytest</code>, this is done by adding <code class="language-plaintext highlighter-rouge">capsys</code> to the input of the testing function and then parsing what it captures.</p>

<p>After <code class="language-plaintext highlighter-rouge">test_parse_args()</code>:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_missing_args</span><span class="p">(</span><span class="n">capsys</span><span class="p">,</span> <span class="n">monkeypatch</span><span class="p">):</span>
  <span class="n">monkeypatch</span><span class="p">.</span><span class="nb">setattr</span><span class="p">(</span><span class="s">'sys.argv'</span><span class="p">,</span> <span class="p">[</span><span class="s">'filetransfer.py'</span><span class="p">])</span>

  <span class="k">with</span> <span class="n">pytest</span><span class="p">.</span><span class="n">raises</span><span class="p">(</span><span class="nb">SystemExit</span><span class="p">):</span>
    <span class="n">filetransfer</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>

  <span class="n">stderr</span> <span class="o">=</span> <span class="n">capsys</span><span class="p">.</span><span class="n">readouterr</span><span class="p">().</span><span class="n">err</span>

  <span class="k">assert</span> <span class="s">'error: the following arguments are required'</span> <span class="ow">in</span> <span class="n">stderr</span>
  <span class="k">assert</span> <span class="s">'id'</span> <span class="ow">in</span> <span class="n">stderr</span>
  <span class="k">assert</span> <span class="s">'source'</span> <span class="ow">in</span> <span class="n">stderr</span>
</code></pre></div></div>

<h3 id="provide-help-text">Provide help text</h3>

<p>Finally, it would be good for the script to have a help argument that explains what the script does.
This case will transfer files from a carrier into a bag, so let’s have the script say that it does that.</p>

<p>The script will exit immediately after printing the help information, so a <code class="language-plaintext highlighter-rouge">with</code> block is needed.
Because the help text is sent to standard oupout instead of standard error, we parse <code class="language-plaintext highlighter-rouge">capsys.readouterr().out</code></p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_cli_help</span><span class="p">(</span><span class="n">capsys</span><span class="p">,</span> <span class="n">monkeypatch</span><span class="p">):</span>
  <span class="n">monkeypatch</span><span class="p">.</span><span class="nb">setattr</span><span class="p">(</span><span class="s">'sys.argv'</span><span class="p">,</span> <span class="p">[</span><span class="s">'filetransfer.py'</span><span class="p">,</span> <span class="s">'-h'</span><span class="p">])</span>

  <span class="k">with</span> <span class="n">pytest</span><span class="p">.</span><span class="n">raises</span><span class="p">(</span><span class="nb">SystemExit</span><span class="p">):</span>
    <span class="n">filetransfer</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>

  <span class="n">stdout</span> <span class="o">=</span> <span class="n">capsys</span><span class="p">.</span><span class="n">readouterr</span><span class="p">().</span><span class="n">out</span>

  <span class="k">assert</span> <span class="s">'transfer files from a carrier into a bag'</span> <span class="ow">in</span> <span class="n">stdout</span>
</code></pre></div></div>

<h3 id="cli-testing-summary">CLI Testing Summary</h3>

<p>The test script should now have 3 new testing functions.
These aren’t perfect test.
You might want to add additional assertions for what the help should look like.
Or you could test what happens when you provide just one of the required arguments.
However, they are a good start for any CLI testing you want to do.</p>

<p>If you don’t fully understand <code class="language-plaintext highlighter-rouge">monkeypatch</code>, <code class="language-plaintext highlighter-rouge">capsys</code>, <code class="language-plaintext highlighter-rouge">SystemExit</code>, or other <code class="language-plaintext highlighter-rouge">pytest</code> features that were introduced, treat these three testing functions as a template to build from until you’re more comfortable with <code class="language-plaintext highlighter-rouge">pytest</code></p>

<p>For now, we can return to writing the script itself.</p>

<h2 id="writing-the-cli-for-filetransferpy">Writing the CLI for <code class="language-plaintext highlighter-rouge">filetransfer.py</code></h2>

<p>First, let’s run the tests.
In a terminal in the the working directory of your script files, run the following.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pytest
</code></pre></div></div>

<p>You should see a report of <code class="language-plaintext highlighter-rouge">3 failed, 1 passed</code>.
The summaries for the failed tests, should look similar to the last lesson.
<code class="language-plaintext highlighter-rouge">module 'filetransfer' has no attribute 'parse_args'</code></p>

<p>We can fix that issue pretty quickly by adding a new function to <code class="language-plaintext highlighter-rouge">filetransfer.py</code></p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parse_args</span><span class="p">():</span>
    <span class="k">return</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">return</span>
</code></pre></div></div>

<p>Running <code class="language-plaintext highlighter-rouge">pytest</code> in the terminal again no yields more specific errors.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FAILED test_python.py::test_required_args - AttributeError: <span class="s1">'NoneType'</span> object has no attribute <span class="s1">'source'</span>
FAILED test_python.py::test_missing_args - Failed: DID NOT RAISE &lt;class <span class="s1">'SystemExit'</span><span class="o">&gt;</span>
FAILED test_python.py::test_cli_help - Failed: DID NOT RAISE &lt;class <span class="s1">'SystemExit'</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>This says that our script does not:</p>

<ol>
  <li>successfully parse command line arguments</li>
  <li>successfully exit when it does not receive required arguments</li>
  <li>successfully exit when it receives an argument to print help</li>
</ol>

<p>We’ll fix these one-by-one using the <code class="language-plaintext highlighter-rouge">argparse</code> module, Python’s built-in module for building command-line interfaces.</p>

<h3 id="adding-argparse-and-parsing-arguments">Adding <code class="language-plaintext highlighter-rouge">argparse</code> and parsing arguments</h3>

<p>To access the functions of <code class="language-plaintext highlighter-rouge">argparse</code>, we need to import it into the script.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">argparse</span>

<span class="k">def</span> <span class="nf">parse_args</span><span class="p">():</span>
    <span class="k">return</span>
<span class="p">...</span>
</code></pre></div></div>

<p>To learn how to use it, or any Python module, it’s helpful to head to the module’s documentation.
The <a href="https://docs.python.org/3/library/argparse.html">documentation for argparse</a> follows a standard documentation structure used for most other standard library modules.</p>

<p>First, there is a minimal working example using good stylistic practice.
You can copy paste this code yourself to test it out.</p>

<p>Next, major concepts of the module are explained and illustrated with examples.
These concepts are typically arranged in order of common usage.
For <code class="language-plaintext highlighter-rouge">argparse</code>, the concepts are:</p>

<ul>
  <li>the <code class="language-plaintext highlighter-rouge">ArgumentParser</code> object</li>
  <li>the <code class="language-plaintext highlighter-rouge">add_argument()</code> method</li>
  <li>the <code class="language-plaintext highlighter-rouge">parse_args()</code> method</li>
  <li>other tools in the module</li>
</ul>

<p>This type of documentation is often not read from start to finish, but skimmed and referenced as needed.
Using <code class="language-plaintext highlighter-rouge">cmd+f</code> to jump to other portions of the page is frequently helpful.</p>

<p>For our script, we will need to:</p>

<ol>
  <li>create an instance of the <code class="language-plaintext highlighter-rouge">ArgumentParser</code> object</li>
  <li>define arguments for <code class="language-plaintext highlighter-rouge">source</code> and <code class="language-plaintext highlighter-rouge">id</code></li>
  <li>parse the arguments before returning it</li>
</ol>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">argparse</span>

<span class="k">def</span> <span class="nf">parse_args</span><span class="p">():</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--source'</span><span class="p">)</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--id'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">parser</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>

</code></pre></div></div>

<p>Because <code class="language-plaintext highlighter-rouge">parser</code> is an instance of the <code class="language-plaintext highlighter-rouge">ArgumentParser</code> class, it has all of the methods of the class, including <code class="language-plaintext highlighter-rouge">add_argument()</code>.
That method allows us to define how the <code class="language-plaintext highlighter-rouge">parser</code> should interpret command-line arguments.
For example, <code class="language-plaintext highlighter-rouge">parser.add_argument('--source')</code> makes it possible to run a command like <code class="language-plaintext highlighter-rouge">python filetransfer.py --source path/to/source</code> and argparse will associate the flag <code class="language-plaintext highlighter-rouge">--source</code> with the input <code class="language-plaintext highlighter-rouge">path/to/source</code>.
We can add further inputs to an <code class="language-plaintext highlighter-rouge">add_argument</code> in order to add optional names, required data types, help text, or other features.</p>

<p>Finally, <code class="language-plaintext highlighter-rouge">parser.parse_args</code> actually performs the work of interpreting arguments received by the script into data that the rest of the script can use.
In general, each argument created in the parser is produced as an attribute of the object returned by <code class="language-plaintext highlighter-rouge">parse_args</code>, e.g. <code class="language-plaintext highlighter-rouge">--source</code> is referenced as <code class="language-plaintext highlighter-rouge">.source</code>.
We’re coopting the name of <code class="language-plaintext highlighter-rouge">parse_args</code> in order to communicate that the results of our function are the results of a <code class="language-plaintext highlighter-rouge">argparse.ArgumentParser.parse_args()</code> method.</p>

<p>Back to the terminal to run <code class="language-plaintext highlighter-rouge">pytest</code> and out test results should now be <code class="language-plaintext highlighter-rouge">2 failed, 2 passed</code>.</p>

<h3 id="requiring-arguments">Requiring arguments</h3>

<p>The missing argument test is still failing.
Just because our script can parse something like <code class="language-plaintext highlighter-rouge">python filetransfer.py --source path/to/source</code>, doesn’t mean that it will exit if we forget that argument, mistype, or have another issue.
To make these non-optional, we need to put further conditions on <code class="language-plaintext highlighter-rouge">add_argument</code></p>

<p>Because making arguments required is very common, <code class="language-plaintext highlighter-rouge">add_argument</code> has its own argument for it, <code class="language-plaintext highlighter-rouge">required</code>.
According to the docs, <code class="language-plaintext highlighter-rouge">required</code> is set to <code class="language-plaintext highlighter-rouge">False</code> by default.
If we want an argument to be required, we need to set it to <code class="language-plaintext highlighter-rouge">True</code> when we define the argument.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">argparse</span>

<span class="k">def</span> <span class="nf">parse_args</span><span class="p">():</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--source'</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--id'</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">parser</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>

</code></pre></div></div>

<p>Back to the terminal to run <code class="language-plaintext highlighter-rouge">pytest</code> and out test results should now be <code class="language-plaintext highlighter-rouge">1 failed, 3 passed</code>.</p>

<h3 id="adding-a-help-function">Adding a help function</h3>

<p>Finally, argparse comes with a built-in help argument.
Running the script with a <code class="language-plaintext highlighter-rouge">-h</code> will print out all of the configuration options chosen for the parser.
To add a description of the entire script to the help output requires a change to the initial <code class="language-plaintext highlighter-rouge">ArgumentParser</code> call.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">argparse</span>

<span class="k">def</span> <span class="nf">parse_args</span><span class="p">():</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s">'transfer files from a carrier into a bag'</span><span class="p">)</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--source'</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--id'</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">parser</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>

</code></pre></div></div>

<p>Back to the terminal to run <code class="language-plaintext highlighter-rouge">pytest</code> and out test results should now be <code class="language-plaintext highlighter-rouge">4 passed</code>.</p>

<h2 id="going-further">Going further</h2>

<p>This is a basic setup for using <code class="language-plaintext highlighter-rouge">argparse</code>.
There a plenty of additional features we could use.
For example, every argument can have its own help text.</p>

<p>Note: as you increase the number of arguments, it becomes harder to read a function call.
You can break the arguments over several lines to improve legibility.
To do so, create a new line after either a parenthesis or a comma and start the new line one tab in from the function.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span>
    <span class="s">'--id'</span><span class="p">,</span>
    <span class="n">help</span><span class="o">=</span><span class="s">'Media ID in the form of M#####-####'</span>
    <span class="n">required</span><span class="o">=</span><span class="bp">True</span>
<span class="p">)</span>
</code></pre></div></div>

<p>We could have a requirement that every argument has specific help text, then write test for that help text, and finally implement that help text.
However, we could also choose to just implement the help text.
Everyone has their own opinions about what features require testing.</p>

<h3 id="better-argument-validation">Better argument validation</h3>

<p>We could get more exact about our requirement though.
What if someone entered an incorrect Media ID, like N12345-0001, M12345_0002, or M12345-000q?
It would be good for the script to report and error and exit.</p>

<p>Let’s write a test for that.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_bad_id</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
  <span class="n">bad_id</span> <span class="o">=</span><span class="s">'N12345-0001'</span>
  <span class="n">monkeypatch</span><span class="p">.</span><span class="nb">setattr</span><span class="p">(</span><span class="s">'sys.argv'</span><span class="p">,</span> <span class="p">[</span><span class="s">'filetransfer.py'</span><span class="p">,</span> <span class="s">'--source'</span><span class="p">,</span> <span class="s">'path/to/source'</span><span class="p">,</span> <span class="s">'--id'</span><span class="p">,</span> <span class="n">bad_id</span><span class="p">])</span>

  <span class="k">with</span> <span class="n">pytest</span><span class="p">.</span><span class="n">raises</span><span class="p">(</span><span class="nb">SystemExit</span><span class="p">):</span>
    <span class="n">filetransfer</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>

  <span class="n">stderr</span> <span class="o">=</span> <span class="n">capsys</span><span class="p">.</span><span class="n">readouterr</span><span class="p">().</span><span class="n">err</span>

  <span class="k">assert</span> <span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">bad_id</span><span class="si">}</span><span class="s"> does not match the required Media ID format of M#####-####'</span> <span class="ow">in</span> <span class="n">stderr</span>
</code></pre></div></div>

<p>Running <code class="language-plaintext highlighter-rouge">pytest</code> should result in 1 failed test.</p>

<p>To validate input, we can use the <code class="language-plaintext highlighter-rouge">add_argument</code> <code class="language-plaintext highlighter-rouge">type</code> argument.
At its most direct level you can require input to be a specific data type like <code class="language-plaintext highlighter-rouge">str</code> or <code class="language-plaintext highlighter-rouge">int</code>.
But, you can also create function to validate custom types.
The pattern for the validation function will be</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">valid_</span><span class="p">...(</span><span class="nb">input</span><span class="p">):</span>
    <span class="c1"># if the input isn't valid
</span>        <span class="c1"># raise an exception
</span>    <span class="c1"># return the input
</span></code></pre></div></div>

<p>For the Media ID, the NYPL pattern is start with M, then 4 to 6 numbers, then a dash, and then end with 4 numbers.
We can express this more succinctly as a regular expression, <code class="language-plaintext highlighter-rouge">M\d{4,6}-\d{4}</code>.
So we’ll import the <code class="language-plaintext highlighter-rouge">re</code> module into our script, in order to use <code class="language-plaintext highlighter-rouge">re.match(r'M\d{4,6}-\d{4}', id)</code>.</p>

<p>Because this function will only be used within the argument parser, we define it inside of <code class="language-plaintext highlighter-rouge">parse_args</code>.
(It may seem strange, but yes, you can define functions in functions.)</p>

<p>Finally, we reference the validator from <code class="language-plaintext highlighter-rouge">add_argument</code> with <code class="language-plaintext highlighter-rouge">type=valid_id</code> (note that it doesn’t have parentheses).</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="k">def</span> <span class="nf">parse_args</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">valid_id</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s">'^M\d{4,6}-\d{4}$'</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">argparse</span><span class="p">.</span><span class="n">ArgumentTypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="nb">id</span><span class="si">}</span><span class="s"> does not match the required Media ID format of M#####-####'</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">id</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="n">ArgumentParser</span><span class="p">(</span>
        <span class="n">description</span><span class="o">=</span><span class="s">'transfer files from a carrier into a bag'</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s">'--source'</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s">'path to the digital carrier'</span>
        <span class="n">required</span><span class="o">=</span><span class="bp">True</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s">'--id'</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s">'media id in the form of M#####-####'</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="n">valid_id</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">parser</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>
</code></pre></div></div>

<p>Back to the terminal to run <code class="language-plaintext highlighter-rouge">pytest</code> and out test results should now be <code class="language-plaintext highlighter-rouge">5 passed</code>.
Note, this was a slightly different rhythm of testing, just one test at a time.
That is yet another choice depending on what you find most useful.</p>

<p>Next lesson, we’ll cover file paths from creating paths to testing for their existence.
We can use that to validate the <code class="language-plaintext highlighter-rouge">--source</code> argument, but for now, we have a good start to the script.</p>

<h2 id="argument-parsing-conclusion">Argument Parsing Conclusion</h2>

<p>Python has a built-in module for creating command-line interfaces called <code class="language-plaintext highlighter-rouge">argparse</code>.
A common way to use this module is to create a self-contained function that invokes the <code class="language-plaintext highlighter-rouge">ArgumentParser</code>, defines each desired argument, and the parses the results.
In practice, this can become so idiomatic that you may skip writing tests for your CLI.</p>

<p>However, writing test can help you keep track of requirements, implement new kinds of features, or for other reasons.
Testing this part of a script can be complicated with all the mocking and exit codes, so the test functions built here are a good starting point if you want to build your own tests.</p>
